const fs = require("fs");
const got = require("got");
const data = require('./data/userData.json');
const Discord = require('discord.js')

const hasteURLs = [
    "https://hst.sh",
    "https://hastebin.com",
    "https://haste.clicksminuteper.net",
    "https://haste.tyman.tech"
]

function randColor() {
    var letters = '0123456789ABCDEF';
    var color = '';
    for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

module.exports = {
    randomEmojis() {
        let choices = new Discord.Collection()
        let choicesLeft = message.guild.emojis.cache.filter(e => e.animated)
        let curChoice = "";
        for (let i = 0; i < Number(args[0]); i++) {
            curChoice = choicesLeft.randomKey()
            choices.set(curChoice, choicesLeft.get(curChoice))
            choicesLeft.delete(curChoice)
        }
        return choices
    },
    getUptime(client) {
        let totalSeconds = (client.uptime / 1000);
        let days = Math.floor(totalSeconds / 86400);
        totalSeconds %= 86400;
        let hours = Math.floor(totalSeconds / 3600);
        totalSeconds %= 3600;
        let minutes = Math.floor(totalSeconds / 60);
        let seconds = Math.floor(totalSeconds % 60);
        let uptime = `${days} days, ${hours} hours, ${minutes} minutes and ${seconds} seconds`;
        let noSecUptime = `${days} days, ${hours} hours and ${minutes} minutes`;
        return {uptime: uptime, noSecUptime: noSecUptime};
    },
    /*getPrefix(message) {
        let p = "~"
        var data = fs.readFileSync("data/serverData.json");
        const json = JSON.parse(data);
        if (json.prefixes[String(message.guild.id)]) {
            p = json.prefixes[String(message.guild.id)]
        }
        return p
    },*/
    async haste(text) {
        for (const url of hasteURLs) {
            try {
                const resp = await got.post(url + "/documents", {
                    body: text
                }).json()
                return `${url}/${resp.key}`
            } catch {
                continue
            }
        }
        throw new Error("Haste failure")
    },
    capitalize(name) {
        name = name.toLowerCase();
        return name.charAt(0).toUpperCase() + name.slice(1)
    },
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    },
    validURL(str) {
        var pattern = new RegExp('^(https?:\\/\\/)?'+ // protocol
        '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|'+ // domain name
        '((\\d{1,3}\\.){3}\\d{1,3}))'+ // OR ip (v4) address
        '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*'+ // port and path
        '(\\?[;&a-z\\d%_.~+=-]*)?'+ // query string
        '(\\#[-a-z\\d_]*)?$','i'); // fragment locator
        return !!pattern.test(str);
    },
    getReactions(message) {
        var data = fs.readFileSync("data.json").toString();
        const json = JSON.parse(data); 
        if (json.reactions.includes(message.guild.id)) {
            return true
        }
        return false
    },
    //const {randColor} = require("../funcs.js")
    randColor: randColor,
    // const {paginate} = require("../funcs.js")
    async paginate(message, embeds) {
        embeds.forEach((e, i) => {
            embeds[i] = embeds[i].setFooter(`Page ${i+1}/${embeds.length} | Click ‚ùî for help!`)
        })
        let curPage = 0;
        if ((typeof embeds) !== "object") return
        const m = await message.channel.send(embeds[curPage])
        m.react("‚è™")
        m.react("‚óÄ")
        m.react("‚èπ")
        m.react("‚ñ∂")
        m.react("‚è©")
        m.react("üî¢")
        m.react("‚ùî")
        const filter = (r, u) => ["‚è™", "‚óÄ", "‚èπ", "‚ñ∂", "‚è©", "üî¢", "‚ùî"].includes(r.emoji.toString())
        coll = m.createReactionCollector(filter)
        let timeout = setTimeout(async () => {
            await m.edit("Timed out.", {embed: null})
            try {
                await m.reactions.removeAll()
            }
            catch {}
            coll.stop()
        }, 300000)
        coll.on("collect", async (r, u) => {
            if (u.id == message.client.user.id) return
            const userReactions = m.reactions.cache.filter(reaction => reaction.users.cache.has(u.id));
            for (const reaction of userReactions.values()) {
                try {
                    await reaction.users.remove(u.id);
                }
                catch {}
            }
            if (u.id != message.author.id) return
            clearTimeout(timeout)
            timeout = setTimeout(async () => {
                await m.edit("Timed out.", {embed: null})
                try {
                    await m.reactions.removeAll()
                }
                catch {}
                coll.stop()
            }, 300000)
            if (r.emoji.toString() == "‚óÄ") {
                if (curPage - 1 < 0) return
                if (!embeds[curPage - 1]) return
                curPage--
                await m.edit(embeds[curPage])
            }
            else if (r.emoji.toString() == "‚ñ∂") {
                if (!embeds[curPage + 1]) return
                curPage++
                m.edit(embeds[curPage])
            }
            else if (r.emoji.toString() == "‚èπ") {
                clearTimeout(timeout)
                await m.edit("Command closed by user.", {embed: null})
                try {
                    await m.reactions.removeAll()
                }
                catch {}
                coll.stop()
            }
            else if (r.emoji.toString() == "‚è™") {
                curPage = 0
                await m.edit(embeds[curPage])
            }
            else if (r.emoji.toString() == "‚è©") {
                curPage = embeds.length - 1
                await m.edit(embeds[curPage])
            }
            else if (r.emoji.toString() == "üî¢") {
                const filter = m => m.author.id == message.author.id && !(isNaN(Number(m.content)))
                const m1 = await message.reply("What page would you like to see? (Must be a number)")
                message.channel.awaitMessages(filter, { max: 1, time: 60000, errors: ['time']})
                .then(async messages => {
                    let resp = messages.array()[0]
                    resp = Number(resp.content)
                    const embedChange = embeds[resp - 1] || null
                    if (embedChange === null) {
                        const mErr = await message.channel.send("Invalid page.")
                        try {
                            await messages.array()[0].delete()
                        }
                        catch {}
                        setTimeout(async () => {
                            await mErr.delete()
                            await m1.delete()
                        }, 10000);
                        return
                    };
                    curPage = resp - 1
                    await m.edit(embedChange)
                    try {
                        await messages.array()[0].delete()
                    }
                    catch {}
                    await m1.delete()
                })
                .catch(async messages => {
                    const mErr = await message.channel.send(`Took too long.`)
                    setTimeout(async () => {
                        await mErr.delete()
                        await m1.delete()
                    }, 10000);
                });
            }
            else if (r.emoji.toString() == "‚ùî") {
                let embed4 = new Discord.MessageEmbed()
                .setTitle('Legend')
                .setDescription('‚è™: first page\n\n‚óÄ: previous page\n\n‚èπ: close command\n\n‚ñ∂: next page\n\n‚è©: last page\n\nüî¢: page picker\n\n‚ùî: toggle help menu')
                .setColor(randColor())
                const e = m.embeds[0]
                const isSame = e.title === embed4.title && e.footer === embed4.footer && e.description === embed4.description
                if (isSame) {
                    await m.edit(embeds[curPage])
                }
                else {
                    await m.edit(embed4)
                }
            }
        })
    },
};